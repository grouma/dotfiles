#!/bin/sh -e
# Copyright (c) 2016 The crouton Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# Monitors keyboard events for the crouton switch command.


# Exits the script with exit code $1, spitting out message $@ to stderr
error() {
    local ecode="$1"
    shift
    if [ "$ecode" -eq 1 ]; then
        echo_color "r" "$*" 1>&2
    else
        echo "$*" 1>&2
    fi
    exit "$ecode"
}

# Setup trap ($1) in case of interrupt or error.
# Traps explicitly do not exit on command error.
# Traps are first disabled to avoid executing clean-up commands twice.
# In the case of interrupts, exit is called to avoid the script continuing.
# $1 must either be empty or end in a semicolon.
settrap() {
    trap "set +e; trap - INT HUP TERM 0; $1 exit 2" INT HUP TERM
    trap "set +e; trap - INT HUP TERM 0; $1" 0
}

# Prepend a command to the existing $TRAP
addtrap() {
    OLDTRAP="$TRAP"
    TRAP="$1;$TRAP"
    settrap "$TRAP"
}

# Revert the last trap change
undotrap() {
    TRAP="$OLDTRAP"
    settrap "$TRAP"
}

# Works mostly like built-in getopts but silently coalesces positional arguments.
# Does not take parameters. Set getopts_string prior to calling.
# Sets getopts_var and getopts_arg.
# $@ will be left with the positional arguments, so you should NOT shift at all.
# In bash, enables alias expansion, but that shouldn't impact anything.
shopt -q -s expand_aliases 2>/dev/null || true
# Running count of the number of positional arguments
# We're done processing if all of the remaining arguments are positional.
getopts_npos=0
getopts_dashdash=''
alias getopts_nextarg='getopts_ret=1
    while [ "$#" -gt "$getopts_npos" ]; do
        if [ -z "$getopts_dashdash" ] && getopts "$getopts_string" getopts_var; then
            if [ "$(($#+1-OPTIND))" -lt "$getopts_npos" ]; then
                # Bad parameter usage ate a positional argument.
                # Generate the proper error message by abusing getopts.
                set -- "-$getopts_var"
                getopts "$getopts_var:" getopts_var
                shift
            fi
            getopts_arg="$OPTARG"
            getopts_ret=0
            # Avoid -- confusion by shifting if OPTARG is set
            if [ -n "$OPTARG" ]; then
                shift "$((OPTIND-1))"
                OPTIND=1
            fi
            break
        fi
        # Do not let getopts consume a --
        if [ "$OPTIND" -gt 1 ]; then
            shift "$((OPTIND-2))"
            if [ "$1" != "--" ]; then
                shift
            fi
        fi
        OPTIND=1
        if [ -z "$getopts_dashdash" -a "$1" = "--" ]; then
            # Still need to loop through to fix the ordering
            getopts_dashdash=y
        else
            set -- "$@" "$1"
            getopts_npos="$((getopts_npos+1))"
        fi
        shift
    done
    [ "$getopts_ret" = 0 ]'

# Compares $RELEASE to the specified releases, assuming $DISTRODIR/releases is
# sorted oldest to newest. Every two parameters are considered criteria that are
# ORed together. The first parameter is the comparator, as provided to "test".
# The second parameter is the release to compare to. A comparison against a
# release from a different distro always fails. Since either $DISTRODIR/releases
# has to be readable or the release list has to be embedded, and RELEASE has to
# be set properly, this function should only be used in the context of targets.
# Returns non-zero if the release doesn't match
# Example:  release -ge quantal -ge wheezy
release() {
    if [ "$(($# % 2))" -ne 0 ]; then
        error 3 "$(echo_color "y" "invalid parameters to release(): $*")"
    fi
    # Load up the list of releases; this will be replaced with a literal list
    local releases="`cat "$DISTRODIR/releases" 2>/dev/null`"
    if [ -z "$releases" ]; then
        error 3 "$(echo_color "y" "list of releases for $DISTRO not found")"
    fi
    # End-of-word regex for awk
    local eow='([^a-z]|$)'
    local relnum="`echo "$releases" | awk "/^$RELEASE$eow/ {print NR; exit}"`"
    if [ -z "$relnum" ]; then
        error 3 "$(echo_color "y" "$RELEASE not found in $DISTRO")"
    fi
    while [ "$#" -ge 2 ]; do
        local cmp="`echo "$releases" | awk "/^$2$eow/ {print NR; exit}"`"
        if [ -n "$cmp" ] && test "$relnum" "$1" "$cmp"; then
            return 0
        fi
        shift 2
    done
    return 1
}

# Large writes to slow devices (e.g. SD card or USB stick) can cause a task to
# be stuck for longer than 120 seconds, which triggers a kernel panic (and an
# immediate reboot). Instead of disabling the timeout altogether, we just make
# sure the kernel does not panic (this is the default configuration of a vanilla
# kernel). See crbug.com/260955 for details.
disablehungtask() {
    echo 0 > /proc/sys/kernel/hung_task_panic
}

# Run an awk program, without buffering its output.
# unbuffered_awk 'program' [argument ...]
# In the awk code, all "print" calls must be replaced by "output"
#
# - Detects whether to run mawk or gawk (mawk is preferred as it is faster),
# - Prepends the definition of the "output" function to the awk program
# - Run the modified awk program.
# mawk needs '-W interactive' to flush the output properly (fflush does not
# work as documented, but apparently this behaviour is intentional, see
# http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=593504).
# Furthermore, fflush is not POSIX so we cannot use any other awk flavor.
unbuffered_awk() {
    local cmd
    if hash mawk 2>/dev/null; then
        cmd="mawk -W interactive"
    elif hash gawk 2>/dev/null; then
        cmd="gawk"
    else
        echo "Cannot find mawk or gawk." 1>&2
        return 1
    fi

    local program="$1"
    shift

    $cmd '
    function output(s) {
        print s
        fflush()
    }
    '"$program" "$@"
}

# Validate a chroot name: It cannot contain any /, and cannot be ".", ".." nor
# an empty string.
validate_name() {
    if [ "${1%/*}" != "$1" -o "$1" = "." -o "$1" = ".." -o -z "$1" ]; then
        return 1
    fi
    return 0
}

# Returns the mountpoint a path is on. The path doesn't need to exist.
# $1: the path to check
# outputs on stdout
getmountpoint() {
    mp="`readlink -m -- "$1"`"
    while ! stat -c '%m' "${mp:-/}" 2>/dev/null; do
        mp="${mp%/*}"
    done
}

# Echos to stderr, or /dev/tty if stdin is a tty but stderr is not
echo_tty() {
    if [ -t 0 -a ! -t 2 ]; then
        echo "$@" 1>/dev/tty
    else
        echo "$@" 1>&2
    fi
}

# Outputs colored text to stdout
# usage: echo_color [l][color] [colored string] [uncolored string]
# Specifying "t" (thick) uses bold text.
# Color can be red, green, yellow, blue, magenta, cyan.
# Color can be specified with just the first letter.
# example: echo_color "tr" "bold red" "normal text"
echo_color() {
    # If not outputting to a tty print no colors.
    if [ ! -t 2 ]; then
        shift
        echo "$@"
        return
    fi
    printf "\033["
    local c="$1"
    if [ "${c#t}" != "$c" ]; then
        printf "1;"
        c="${c#t}"
    else
        printf "0;"
    fi
    case "$c" in
        r*) printf "31m";;
        g*) printf "32m";;
        y*) printf "33m";;
        b*) printf "34m";;
        m*) printf "35m";;
        c*) printf "36m";;
         *) printf "37m";;
    esac
    shift
    local s='\n'
    if [ "$1" = '-n' ]; then
        s=''
        shift
    fi
    echo '-n' "$1"
    printf "\033[0m"
    shift
    echo '-n' "$*"
    printf "$s"
}

# Websocket interface
PIPEDIR='/tmp/crouton-ext'
CRIATDISPLAY="$PIPEDIR/kiwi-display"
CROUTONLOCKDIR='/tmp/crouton-lock'

# Write a command to croutonwebsocket, and read back response
websocketcommand() {
    # Check that $PIPEDIR and the FIFO pipes exist
    if ! [ -d "$PIPEDIR" -a -p "$PIPEDIR/in" -a -p "$PIPEDIR/out" ]; then
        echo "EError $PIPEDIR/in or $PIPEDIR/out are not pipes."
        exit 0
    fi

    if ! timeout 3 \
           sh -c "flock 5; cat > '$PIPEDIR/in';
                  cat '$PIPEDIR/out'" 5>"$PIPEDIR/lock"; then
        echo "EError timeout"
    fi
}

# hexdump output format variables
if getconf LONG_BIT | grep -q 32; then
    HEXDUMP_FMT='2/4 "%u 0 " " " 2/2 "%u " " " 1/4 "%u " "\n"'
else
    HEXDUMP_FMT='4/4 "%u " " " 2/2 "%u " " " 1/4 "%u " "\n"'
fi
SECONDS_LO='$1'
SECONDS_HI='$2'
USECONDS_LO='$3'
USECONDS_HI='$4'
TYPE='$5'
KEY='$6'
STATE='$7'

# constants
TYPE_EV_KEY=1
STATE_DOWN=1
STATE_UP=0
KEY_LEFTCTRL=29
KEY_LEFTALT=56
KEY_LEFTSHIFT=42
KEY_RIGHTCTRL=97
KEY_RIGHTALT=100
KEY_RIGHTSHIFT=54
KEY_F1=24
KEY_F2=60

EVENT_DEV_POLL=15

# Only one at a time. xbindkeys lockfile is for legacy compatibility
mkdir -m 775 -p "$CROUTONLOCKDIR"
exec 3>>"$CROUTONLOCKDIR/xbindkeys"
if ! flock -n 3; then
    echo "Another instance of ${0##*/} running, waiting..."
    flock 3
fi

# Reset event variables to handle strange environments
unset `set | grep -o '^event[0-9]*'` 2>/dev/null || true

# Poll for new event files and dump the output
while :; do
    # Clean up old hexdumps and start new ones
    for event in `set | grep -o '^event[0-9]*'` /dev/input/event*; do
        # Check if the event file is already monitored
        eval "pid=\"\${${event##*/}:-0}\""
        if [ "$pid" != 0 ]; then
            # Check if it's still running
            if kill -0 "$pid" 2>/dev/null; then
                continue
            fi
            wait "$pid" || true
        fi
        # Clean up old variables
        if [ "${event#/}" = "$event" ]; then
            unset "$event"
        else
            # Read in the event files and split into input_event fields
            stdbuf -oL hexdump -e "$HEXDUMP_FMT" "$event" &
            eval "${event##*/}='$!'"
        fi
    done
    # Avoid picking up the event variable
    unset event
    # Kill all event daemons
    pids="`set | sed -n 's/^event[0-9]*=.\(.*\).$/\1/p' | tr '\n' ' '`"
    settrap "kill $pids 2>/dev/null;"
    # Wait for next poll
    sleep "$EVENT_DEV_POLL"
done | unbuffered_awk "
    function update() {
        c = lc || rc; s = ls || rs; a = la || ra
        if (!cmd && c && s && a && p) {
            cmd = \"p\"
        } else if (!cmd && c && s && a && n) {
            cmd = \"n\"
        } else if (cmd && !c && !s && !a && !p && !n) {
            system(\"/usr/local/bin/croutoncycle \" cmd)
            cmd = \"\"
        }
    }
    $TYPE == $TYPE_EV_KEY && $KEY == $KEY_LEFTCTRL   { lc = $STATE; update() }
    $TYPE == $TYPE_EV_KEY && $KEY == $KEY_LEFTSHIFT  { ls = $STATE; update() }
    $TYPE == $TYPE_EV_KEY && $KEY == $KEY_LEFTALT    { la = $STATE; update() }
    $TYPE == $TYPE_EV_KEY && $KEY == $KEY_RIGHTCTRL  { rc = $STATE; update() }
    $TYPE == $TYPE_EV_KEY && $KEY == $KEY_RIGHTSHIFT { rs = $STATE; update() }
    $TYPE == $TYPE_EV_KEY && $KEY == $KEY_RIGHTALT   { ra = $STATE; update() }
    $TYPE == $TYPE_EV_KEY && $KEY == $KEY_F1         {  p = $STATE; update() }
    $TYPE == $TYPE_EV_KEY && $KEY == $KEY_F2         {  n = $STATE; update() }
"
